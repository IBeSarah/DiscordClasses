name: Post JSON module diff

on:
  push:
    branches:
      - main

jobs:
  post-diff:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Install Node dependencies
        run: npm install lodash fast-levenshtein

      - name: Set up JSON files safely
        run: |
          # current.json: always exists
          git show HEAD:discordclasses.json > current.json 2>/dev/null || echo '{}' > current.json
          # previous.json: if no previous commit, fallback to empty object
          git show HEAD^:discordclasses.json > previous.json 2>/dev/null || echo '{}' > previous.json
          # validate JSON format
          node -e "JSON.parse(require('fs').readFileSync('current.json'))" || echo '{}' > current.json
          node -e "JSON.parse(require('fs').readFileSync('previous.json'))" || echo '{}' > previous.json

      - name: Post structured module diff
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const _ = require('lodash');
            const levenshtein = require('fast-levenshtein');

            let prev = {};
            let curr = {};

            try { prev = JSON.parse(fs.readFileSync('previous.json', 'utf8')); } catch(e) {
              console.warn("Failed to parse previous.json, using empty object");
            }
            try { curr = JSON.parse(fs.readFileSync('current.json', 'utf8')); } catch(e) {
              console.warn("Failed to parse current.json, using empty object");
            }

            const MAX_COMMENT_LENGTH = 65536;
            const header = `ðŸ§© **Changes in \`discordclasses.json\`:**\n\n`;

            function moduleItems(obj) {
              if (!obj) return [];
              return Object.entries(obj).map(([k,v]) => `${k}: ${v}`);
            }

            function detectRenames(removed, added) {
              const renames = [];
              const unmatchedAdded = new Set(added);
              removed.forEach(rem => {
                let bestMatch = null;
                let bestDist = Infinity;
                unmatchedAdded.forEach(add => {
                  const dist = levenshtein.get(rem, add);
                  if (dist < bestDist && dist <= Math.max(rem.length, add.length)*0.4) {
                    bestDist = dist;
                    bestMatch = add;
                  }
                });
                if(bestMatch) {
                  renames.push({from: rem, to: bestMatch});
                  unmatchedAdded.delete(bestMatch);
                }
              });
              const newRemoved = removed.filter(r => !renames.some(x=>x.from===r));
              const newAdded = Array.from(unmatchedAdded);
              return {renames, newRemoved, newAdded};
            }

            function detectMoves(prevObj, currObj) {
              const moves = [];
              const prevFlat = {};
              Object.entries(prevObj).forEach(([mod, obj]) => { prevFlat[mod] = moduleItems(obj); });
              const currFlat = {};
              Object.entries(currObj).forEach(([mod, obj]) => { currFlat[mod] = moduleItems(obj); });

              Object.entries(prevFlat).forEach(([fromMod, items]) => {
                items.forEach(item => {
                  Object.entries(currFlat).forEach(([toMod, currItems]) => {
                    if(fromMod !== toMod && currItems.includes(item)) {
                      moves.push({item, from: fromMod, to: toMod});
                      currFlat[toMod] = currItems.filter(x=>x!==item);
                      prevFlat[fromMod] = prevFlat[fromMod].filter(x=>x!==item);
                    }
                  });
                });
              });

              return moves;
            }

            function compareModules(prevObj, currObj) {
              const sections = [];
              const summary = [];
              const allModules = _.union(Object.keys(prevObj), Object.keys(currObj));

              const moves = detectMoves(prevObj, currObj);

              allModules.forEach(mod => {
                let prevItems = moduleItems(prevObj[mod]);
                let currItems = moduleItems(currObj[mod]);

                const movedFromThis = moves.filter(m => m.from===mod);
                const movedToThis = moves.filter(m => m.to===mod);

                prevItems = prevItems.filter(x => !movedFromThis.some(m=>m.item===x));
                currItems = currItems.filter(x => !movedToThis.some(m=>m.item===x));

                let removed = _.difference(prevItems, currItems);
                let added = _.difference(currItems, prevItems);

                const {renames, newRemoved, newAdded} = detectRenames(removed, added);
                removed = newRemoved;
                added = newAdded;

                const totalRenamed = renames.length + movedFromThis.filter(m => renames.some(r => r.from === m.item)).length;

                if (removed.length || added.length || totalRenamed || movedFromThis.length) {
                  const movedSummary = movedFromThis.map(m => {
                    const rename = renames.find(r => r.from === m.item);
                    if(rename) return `"${m.item}"â†’${m.to} (renamed to "${rename.to}")`;
                    return `"${m.item}"â†’${m.to}`;
                  }).join(', ');

                  summary.push(`- ${mod}: +${added.length} / -${removed.length} / ~${totalRenamed} / moved: ${movedSummary || 'none'}`);

                  // Build collapsible section
                  let section = `<details>\n<summary>Module ${mod}: +${added.length} / -${removed.length} / ~${totalRenamed} / moved: ${movedSummary || 'none'}</summary>\n\n`;

                  if (removed.length) {
                    section += '#### Removed\n';
                    removed.forEach(it => section += `-"${it}"\n`);
                  }
                  if (added.length) {
                    section += '#### Added\n';
                    added.forEach(it => section += `+"${it}"\n`);
                  }

                  const pureRenames = renames.filter(r => !movedFromThis.some(m=>m.item===r.from));
                  if (pureRenames.length) {
                    section += '#### Renamed\n';
                    pureRenames.forEach(r => section += `"${r.from}" to "${r.to}"\n`);
                  }

                  if (movedFromThis.length) {
                    section += '#### Moved & Renamed\n';
                    movedFromThis.forEach(m => {
                      const rename = renames.find(r => r.from===m.item);
                      const display = rename ? `"${m.item}" to module ${m.to} (renamed to "${rename.to}")` : `"${m.item}" to module ${m.to}`;
                      section += display + '\n';
                    });
                  }

                  section += '\n</details>\n';
                  sections.push(section);
                }
              });

              const summaryText = summary.length ? `**Summary of changes:**\n${summary.join('\n')}\n\n` : '';
              return summaryText + sections.join('\n');
            }

            const diffText = compareModules(prev, curr);

            if(!diffText.trim()) {
              console.log("No changes to post");
              return;
            }

            function splitText(text, maxLength) {
              const chunks = [];
              let start=0;
              while(start<text.length){
                chunks.push(text.slice(start, start+maxLength));
                start+=maxLength;
              }
              return chunks;
            }

            const chunks = splitText(diffText, MAX_COMMENT_LENGTH - header.length);

            for(let i=0; i<chunks.length; i++){
              const comment = chunks.length>1
                ? `${header}**Part ${i+1} of ${chunks.length}**\n\n${chunks[i]}`
                : `${header}${chunks[i]}`;

              console.log(`Posting comment part ${i+1}/${chunks.length}`);
              await github.rest.repos.createCommitComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: context.sha,
                body: comment
              });
            }
