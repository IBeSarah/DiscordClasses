name: Comment Class Diff

on:
  push:
    branches:
      - main
    paths:
      - discordclasses.json  # Trigger only on this file

jobs:
  post-diff:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Install Node dependencies
        run: npm install lodash fast-levenshtein axios

      - name: Diff and post to Discord/GitHub
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
        run: |
          const fs = require('fs');
          const _ = require('lodash');
          const axios = require('axios');
          const levenshtein = require('fast-levenshtein');

          // Load previous and current JSON
          const prev = JSON.parse(fs.readFileSync('discordclasses.json', 'utf8'));
          const curr = JSON.parse(require('child_process').execSync(`git show HEAD:discordclasses.json`).toString());

          const addedModules = {};
          const removedModules = {};
          const renamedModules = {};
          const movedModules = {};

          const usedCurr = new Set();

          // Detect module moves
          for (const oldId of Object.keys(prev)) {
            if (curr[oldId]) continue; // still exists, no move

            let bestMatch = null;
            let bestScore = Infinity;

            for (const newId of Object.keys(curr)) {
              if (usedCurr.has(newId)) continue;

              const oldKeys = Object.keys(prev[oldId]);
              const newKeys = Object.keys(curr[newId]);

              const keyStrOld = oldKeys.join(',');
              const keyStrNew = newKeys.join(',');

              const score = levenshtein.get(keyStrOld, keyStrNew);
              if (score < bestScore) {
                bestScore = score;
                bestMatch = newId;
              }
            }

            // Use key similarity threshold
            if (bestMatch) {
              const oldKeysSet = new Set(Object.keys(prev[oldId]));
              const newKeysSet = new Set(Object.keys(curr[bestMatch]));
              const intersection = [...oldKeysSet].filter(k => newKeysSet.has(k));
              const similarity = intersection.length / Math.max(oldKeysSet.size, newKeysSet.size);

              if (similarity >= 0.5) { // 50% or more keys overlap
                movedModules[oldId] = { to: bestMatch, keys: [...intersection.filter(k => prev[oldId][k] !== curr[bestMatch][k])] };
                usedCurr.add(bestMatch);
              }
            }
          }

          // Detect additions, removals, renames
          for (const key of new Set([...Object.keys(prev), ...Object.keys(curr)])) {
            const oldMod = prev[key] || {};
            const newMod = curr[key] || {};

            // Added keys
            for (const k of Object.keys(newMod)) {
              if (!oldMod.hasOwnProperty(k)) {
                addedModules[key] = addedModules[key] || [];
                addedModules[key].push(k);
              }
            }

            // Removed keys
            for (const k of Object.keys(oldMod)) {
              if (!newMod.hasOwnProperty(k)) {
                removedModules[key] = removedModules[key] || [];
                removedModules[key].push(k);
              }
            }

            // Renamed keys (value changed)
            for (const k of Object.keys(newMod)) {
              if (oldMod[k] && oldMod[k] !== newMod[k]) {
                renamedModules[key] = renamedModules[key] || [];
                renamedModules[key].push(k);
              }
            }
          }

          function formatDiffBlock(title, moduleId, keys, type) {
            if (!keys || keys.length === 0) return '';
            const lines = keys.map(k => {
              switch (type) {
                case 'added': return `+ "${k}": "${curr[moduleId][k]}"`;
                case 'removed': return `- "${k}": "${prev[moduleId][k]}"`;
                case 'renamed':
                case 'moved':
                  return `- "${k}": "${prev[moduleId][k]}"\n+ "${k}": "${curr[moduleId][k]}"`;
              }
            }).join('\n');
            return `### ${title} in module ${moduleId}\n\`\`\`diff\n${lines}\n\`\`\`\n`;
          }

          // Build full output for GitHub
          let githubOutput = '';
          for (const [mod, keys] of Object.entries(addedModules)) githubOutput += formatDiffBlock('Added', mod, keys, 'added');
          for (const [mod, keys] of Object.entries(removedModules)) githubOutput += formatDiffBlock('Removed', mod, keys, 'removed');
          for (const [mod, keys] of Object.entries(renamedModules)) githubOutput += formatDiffBlock('Renamed', mod, keys, 'renamed');
          for (const [mod, info] of Object.entries(movedModules)) githubOutput += formatDiffBlock('Moved', mod, info.keys, 'moved');

          if (!githubOutput) githubOutput = 'No changes detected.';

          // Post GitHub comments
          const MAX_COMMENT_LENGTH = 65000;
          function splitText(text, maxLength) {
            const chunks = [];
            let start = 0;
            while (start < text.length) {
              chunks.push(text.slice(start, start + maxLength));
              start += maxLength;
            }
            return chunks;
          }
          const githubChunks = splitText(githubOutput, MAX_COMMENT_LENGTH);
          const { Octokit } = require("@octokit/rest");
          const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

          for (let i = 0; i < githubChunks.length; i++) {
            const body = githubChunks.length > 1
              ? `**Part ${i + 1} of ${githubChunks.length}**\n\n${githubChunks[i]}`
              : githubChunks[i];

            octokit.rest.repos.createCommitComment({
              owner: process.env.GITHUB_REPOSITORY.split('/')[0],
              repo: process.env.GITHUB_REPOSITORY.split('/')[1],
              commit_sha: process.env.GITHUB_SHA,
              body,
            });
          }

          // Build Discord summary (short overview)
          function summarize(mods) {
            return Object.entries(mods).map(([mod, keys]) => {
              if (typeof keys === 'object' && keys.to) { // moved
                return `Module ${mod}: Moved: ${keys.keys.length}`;
              }
              return `Module ${mod}: ${keys.length}`;
            }).join(', ');
          }
          const summaryLines = [];
          if (Object.keys(addedModules).length) summaryLines.push(`Added: ${summarize(addedModules)}`);
          if (Object.keys(removedModules).length) summaryLines.push(`Removed: ${summarize(removedModules)}`);
          if (Object.keys(renamedModules).length) summaryLines.push(`Renamed: ${summarize(renamedModules)}`);
          if (Object.keys(movedModules).length) summaryLines.push(`Moved: ${summarize(movedModules)}`);

          const commitUrl = `https://github.com/${process.env.GITHUB_REPOSITORY}/commit/${process.env.GITHUB_SHA}`;
          const discordMessage = `**Module changes summary**\n${summaryLines.join('\n')}\n\nView full list of changes here: ${commitUrl}`;

          axios.post(process.env.DISCORD_WEBHOOK_URL, { content: discordMessage })
            .then(() => console.log('Discord post successful'))
            .catch(err => console.error('Discord post failed:', err.message));
