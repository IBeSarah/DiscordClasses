name: Post JSON module diff

on:
  push:
    branches:
      - main

jobs:
  post-diff:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Install Node dependencies
        run: npm install lodash fast-levenshtein

      - name: Set up JSON files
        run: |
          git show HEAD:discordclasses.json > current.json || echo '{}' > current.json
          git show HEAD^:discordclasses.json > previous.json || echo '{}' > previous.json

      - name: Post structured module diff with per-item detection and summary
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const _ = require('lodash');

            const prev = JSON.parse(fs.readFileSync('previous.json', 'utf8'));
            const curr = JSON.parse(fs.readFileSync('current.json', 'utf8'));

            const MAX_COMMENT_LENGTH = 65536;
            const header = `ðŸ§© **Changes in \`discordclasses.json\`:**\n\n`;

            function compareModules(prevObj, currObj) {
              const sections = [];
              const moduleStats = {};

              const prevMap = new Map();
              const currMap = new Map();

              Object.entries(prevObj).forEach(([mod, items]) => {
                Object.entries(items || {}).forEach(([key, val]) => {
                  prevMap.set(key, { module: mod, value: val });
                });
              });

              Object.entries(currObj).forEach(([mod, items]) => {
                Object.entries(items || {}).forEach(([key, val]) => {
                  currMap.set(key, { module: mod, value: val });
                });
              });

              const allKeys = _.union(Array.from(prevMap.keys()), Array.from(currMap.keys()));

              const added = [];
              const removed = [];
              const renamed = [];
              const moved = [];

              allKeys.forEach(key => {
                const prevItem = prevMap.get(key);
                const currItem = currMap.get(key);

                if (!prevItem && currItem) {
                  added.push({ module: currItem.module, key, value: currItem.value });
                  moduleStats[currItem.module] = moduleStats[currItem.module] || { added: 0, removed: 0, renamed: 0, moved: 0 };
                  moduleStats[currItem.module].added++;
                } else if (prevItem && !currItem) {
                  removed.push({ module: prevItem.module, key, value: prevItem.value });
                  moduleStats[prevItem.module] = moduleStats[prevItem.module] || { added: 0, removed: 0, renamed: 0, moved: 0 };
                  moduleStats[prevItem.module].removed++;
                } else if (prevItem.value !== currItem.value) {
                  renamed.push({ module: currItem.module, key, from: prevItem.value, to: currItem.value });
                  moduleStats[currItem.module] = moduleStats[currItem.module] || { added: 0, removed: 0, renamed: 0, moved: 0 };
                  moduleStats[currItem.module].renamed++;
                } else if (prevItem.module !== currItem.module) {
                  moved.push({ key, from: prevItem.module, to: currItem.module, value: currItem.value });
                  moduleStats[prevItem.module] = moduleStats[prevItem.module] || { added: 0, removed: 0, renamed: 0, moved: 0 };
                  moduleStats[currItem.module] = moduleStats[currItem.module] || { added: 0, removed: 0, renamed: 0, moved: 0 };
                  moduleStats[prevItem.module].moved++;
                  moduleStats[currItem.module].moved++;
                }
              });

              // Format summary
              const summaryLines = [];
              Object.entries(moduleStats).forEach(([mod, stats]) => {
                summaryLines.push(`Module ${mod}: +${stats.added} / -${stats.removed} / ~${stats.renamed} / moved:${stats.moved}`);
              });
              if (summaryLines.length) {
                sections.push(`**Summary:**\n${summaryLines.join('\n')}`);
              }

              // Format detailed sections
              if (added.length) {
                const mods = _.groupBy(added, 'module');
                for (const [mod, items] of Object.entries(mods)) {
                  sections.push(`### Added in module ${mod}`);
                  items.forEach(it => sections.push(`"${it.key}": "${it.value}"`));
                }
              }

              if (removed.length) {
                const mods = _.groupBy(removed, 'module');
                for (const [mod, items] of Object.entries(mods)) {
                  sections.push(`### Removed from module ${mod}`);
                  items.forEach(it => sections.push(`"${it.key}": "${it.value}"`));
                }
              }

              if (renamed.length) {
                const mods = _.groupBy(renamed, 'module');
                for (const [mod, items] of Object.entries(mods)) {
                  sections.push(`### Renamed in module ${mod}`);
                  items.forEach(it => sections.push(`"${it.key}": "${it.from}" to "${it.to}"`));
                }
              }

              if (moved.length) {
                moved.forEach(it => {
                  sections.push(`### Moved from module ${it.from} to ${it.to}`);
                  sections.push(`"${it.key}": "${it.value}"`);
                });
              }

              return sections.join('\n\n');
            }

            const diffText = compareModules(prev, curr);

            if (!diffText.trim()) {
              console.log("No changes to post");
              return;
            }

            function splitText(text, maxLength) {
              const chunks = [];
              let start = 0;
              while (start < text.length) {
                chunks.push(text.slice(start, start + maxLength));
                start += maxLength;
              }
              return chunks;
            }

            const chunks = splitText(diffText, MAX_COMMENT_LENGTH - header.length);

            for (let i = 0; i < chunks.length; i++) {
              const comment = chunks.length > 1
                ? `${header}**Part ${i + 1} of ${chunks.length}**\n\n${chunks[i]}`
                : `${header}${chunks[i]}`;

              await github.rest.repos.createCommitComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: context.sha,
                body: comment,
              });

              console.log(`Posted comment part ${i + 1}/${chunks.length}`);
            }
