name: Post JSON module diff

on:
  push:
    branches:
      - main

jobs:
  post-diff:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Install Node dependencies
        run: npm install lodash fast-levenshtein

      - name: Set up JSON files
        run: |
          git show HEAD:discordclasses.json > current.json || echo '{}' > current.json
          git show HEAD^:discordclasses.json > previous.json || echo '{}' > previous.json

      - name: Post structured module diff with summary and rename detection
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const _ = require('lodash');
            const levenshtein = require('fast-levenshtein');

            const prev = JSON.parse(fs.readFileSync('previous.json', 'utf8'));
            const curr = JSON.parse(fs.readFileSync('current.json', 'utf8'));

            const MAX_COMMENT_LENGTH = 65536;
            const header = `ðŸ§© **Changes in \`discordclasses.json\`:**\n\n`;

            function itemToString(item) {
              if (item == null) return '';
              if (typeof item === 'string') return item;
              if (typeof item === 'object') {
                if ('name' in item) return item.name;
                return JSON.stringify(item);
              }
              return String(item);
            }

            function extractNames(moduleData) {
              if (!moduleData) return [];
              if (Array.isArray(moduleData)) return moduleData.map(itemToString);
              if (typeof moduleData === 'object') return [itemToString(moduleData)];
              return [String(moduleData)];
            }

            function detectRenames(removed, added) {
              const renames = [];
              const unmatchedAdded = new Set(added);

              removed.forEach(rem => {
                let bestMatch = null;
                let bestDist = Infinity;
                unmatchedAdded.forEach(add => {
                  const dist = levenshtein.get(rem, add);
                  if (dist < bestDist && dist <= Math.max(rem.length, add.length) * 0.4) {
                    bestDist = dist;
                    bestMatch = add;
                  }
                });
                if (bestMatch) {
                  renames.push({ from: rem, to: bestMatch });
                  unmatchedAdded.delete(bestMatch);
                }
              });

              const newRemoved = removed.filter(r => !renames.some(x => x.from === r));
              const newAdded = Array.from(unmatchedAdded);

              return { renames, newRemoved, newAdded };
            }

            function compareModules(prevObj, currObj) {
              const sections = [];
              const summary = [];
              const allModules = _.union(Object.keys(prevObj), Object.keys(currObj));

              allModules.forEach(moduleName => {
                const prevItems = extractNames(prevObj[moduleName]);
                const currItems = extractNames(currObj[moduleName]);

                let removed = _.difference(prevItems, currItems);
                let added = _.difference(currItems, prevItems);

                const { renames, newRemoved, newAdded } = detectRenames(removed, added);
                removed = newRemoved;
                added = newAdded;

                if (removed.length || added.length || renames.length) {
                  summary.push(`- ${moduleName}: +${added.length} / -${removed.length} / ~${renames.length}`);
                  let section = `### Module: ${moduleName}\n`;
                  if (removed.length) {
                    section += '#### Removed\n';
                    removed.forEach(item => section += `-"${item}"\n`);
                  }
                  if (added.length) {
                    section += '#### Added\n';
                    added.forEach(item => section += `+"${item}"\n`);
                  }
                  if (renames.length) {
                    section += '#### Renamed\n';
                    renames.forEach(r => section += `"${r.from}" to "${r.to}"\n`);
                  }
                  sections.push(section);
                }
              });

              const summaryText = summary.length
                ? `**Summary:**\n${summary.join('\n')}\n\n`
                : '';

              return summaryText + sections.join('\n');
            }

            const diffText = compareModules(prev, curr);
            if (!diffText.trim()) {
              console.log("No changes to post");
              return;
            }

            function splitText(text, maxLength) {
              const chunks = [];
              let start = 0;
              while (start < text.length) {
                chunks.push(text.slice(start, start + maxLength));
                start += maxLength;
              }
              return chunks;
            }

            const chunks = splitText(diffText, MAX_COMMENT_LENGTH - header.length);

            for (let i = 0; i < chunks.length; i++) {
              const comment = chunks.length > 1
                ? `${header}**Part ${i + 1} of ${chunks.length}**\n\n${chunks[i]}`
                : `${header}${chunks[i]}`;

              await github.rest.repos.createCommitComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: context.sha,
                body: comment,
              });

              console.log(`Posted comment part ${i + 1}/${chunks.length}`);
            }
